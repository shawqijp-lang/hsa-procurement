import { useState } from "react";
import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import { Button } from "@/components/ui/button";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Input } from "@/components/ui/input";
import { Textarea } from "@/components/ui/textarea";
import { Label } from "@/components/ui/label";
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogTrigger, DialogFooter } from "@/components/ui/dialog";
import { Building, Home, Stethoscope, Plus, Pencil, Trash2, X, Edit, GripVertical } from "lucide-react";
import { useDashboardSettings } from "@/hooks/useDashboardSettings";
import { apiRequest } from "@/lib/queryClient";
import { useAuth } from "@/hooks/useAuth";


import LoadingSpinner from "@/components/ui/loading-spinner";
import { useToast } from "@/hooks/use-toast";

type LucideIcon = typeof Building | typeof Home | typeof Stethoscope;

interface SubPoint {
  ar: string;
  en?: string;
}

interface SubTask {
  ar: string;
  en?: string;
}

interface ChecklistTemplate {
  id: number;
  locationId: number;
  categoryAr: string;
  categoryEn: string;
  taskAr: string;
  taskEn: string;
  descriptionAr?: string;
  descriptionEn?: string;
  orderIndex: number;
  isActive: boolean;
  subPoints?: SubPoint[];
  subTasks?: SubTask[];
  multiTasks?: MultiTask[];
  createdAt: string;
  updatedAt: string;
}

interface Location {
  id: number;
  nameAr: string;
  nameEn: string;
  icon: string;
}

interface NewTask {
  categoryAr: string;
  categoryEn: string;
  taskAr: string;
  taskEn: string;
  descriptionAr: string;
  descriptionEn: string;
  multiTasks: MultiTask[];
}

interface MultiTask {
  ar: string;
  en?: string;
}



const iconMap = {
  building: Building,
  home: Home,
  'clinic-medical': Stethoscope,
};

export default function ChecklistManager() {
  const [selectedLocationId, setSelectedLocationId] = useState<number | null>(null);
  const [isAddDialogOpen, setIsAddDialogOpen] = useState(false);
  const [isEditDialogOpen, setIsEditDialogOpen] = useState(false);
  const [editingTask, setEditingTask] = useState<ChecklistTemplate | null>(null);
  const [draggedTemplate, setDraggedTemplate] = useState<ChecklistTemplate | null>(null);
  const [dragOverTemplate, setDragOverTemplate] = useState<ChecklistTemplate | null>(null);
  const [newTask, setNewTask] = useState<NewTask>({
    categoryAr: "",
    categoryEn: "",
    taskAr: "",
    taskEn: "",
    descriptionAr: "",
    descriptionEn: "",
    multiTasks: [{ ar: "", en: "" }], // Start with one task by default
  });
  const [editTask, setEditTask] = useState<NewTask>({
    categoryAr: "",
    categoryEn: "",
    taskAr: "",
    taskEn: "",
    descriptionAr: "",
    descriptionEn: "",
    multiTasks: [{ ar: "", en: "" }],
  });
  
  const { toast } = useToast();
  const queryClient = useQueryClient();
  const { isOffline } = useAuth();



  // Multi-tasks management functions
  const addMultiTask = () => {
    setNewTask({
      ...newTask,
      multiTasks: [...newTask.multiTasks, { ar: "", en: "" }]
    });
  };

  const removeMultiTask = (index: number) => {
    setNewTask({
      ...newTask,
      multiTasks: newTask.multiTasks.filter((_, i) => i !== index)
    });
  };

  const updateMultiTask = (index: number, field: 'ar' | 'en', value: string) => {
    const updatedMultiTasks = [...newTask.multiTasks];
    updatedMultiTasks[index] = { ...updatedMultiTasks[index], [field]: value };
    setNewTask({
      ...newTask,
      multiTasks: updatedMultiTasks
    });
  };

  // Edit task multi-tasks management functions
  const addEditMultiTask = () => {
    setEditTask({
      ...editTask,
      multiTasks: [...editTask.multiTasks, { ar: "", en: "" }]
    });
  };

  const removeEditMultiTask = (index: number) => {
    setEditTask({
      ...editTask,
      multiTasks: editTask.multiTasks.filter((_, i) => i !== index)
    });
  };

  const updateEditMultiTask = (index: number, field: 'ar' | 'en', value: string) => {
    const updatedMultiTasks = [...editTask.multiTasks];
    updatedMultiTasks[index] = { ...updatedMultiTasks[index], [field]: value };
    setEditTask({
      ...editTask,
      multiTasks: updatedMultiTasks
    });
  };



  const resetNewTask = () => {
    setNewTask({
      categoryAr: "",
      categoryEn: "",
      taskAr: "",
      taskEn: "",
      descriptionAr: "",
      descriptionEn: "",
      multiTasks: [{ ar: "", en: "" }],
    });
  };

  const resetEditTask = () => {
    setEditTask({
      categoryAr: "",
      categoryEn: "",
      taskAr: "",
      taskEn: "",
      descriptionAr: "",
      descriptionEn: "",
      multiTasks: [{ ar: "", en: "" }],
    });
  };

  // Get all locations
  const { data: locations, isLoading: locationsLoading, error: locationsError } = useQuery<Location[]>({
    queryKey: ['/api/locations'],
    staleTime: 0, // Never use cache - always fresh data
    gcTime: 0, // Don't keep old data
    refetchOnWindowFocus: true,
    refetchOnMount: true, // Always refetch when component mounts
    retry: (failureCount, error) => {
      // Don't retry on authentication errors
      if (error?.message?.includes('401') || error?.message?.includes('403')) {
        return false;
      }
      return failureCount < 2;
    },
  });

  // Get templates for selected location
  const { data: templates, isLoading: templatesLoading, error: templatesError } = useQuery<ChecklistTemplate[]>({
    queryKey: [`/api/locations/${selectedLocationId}/templates`],
    enabled: selectedLocationId !== null,
    retry: (failureCount, error) => {
      // Don't retry on authentication errors
      if (error?.message?.includes('401') || error?.message?.includes('403')) {
        return false;
      }
      return failureCount < 2;
    },
  });

  // Add new task mutation
  const addTaskMutation = useMutation({
    mutationFn: async (taskData: NewTask & { locationId: number }) => {
      console.log('üöÄ Frontend: Adding new task with data:', taskData);
      return apiRequest(`/api/checklist-templates`, 'POST', taskData);
    },
    onSuccess: (data) => {
      console.log('‚úÖ Frontend: Task added successfully:', data);
      queryClient.invalidateQueries({ queryKey: [`/api/locations/${selectedLocationId}/templates`] });
      resetNewTask();
      setIsAddDialogOpen(false);
      toast({
        title: "ÿ™ŸÖ ÿ•ÿ∂ÿßŸÅÿ© ÿßŸÑÿ®ŸÜÿØ ÿ®ŸÜÿ¨ÿßÿ≠",
        description: `ÿ™ŸÖ ÿ•ÿ∂ÿßŸÅÿ© "${data.taskAr}" ŸÖÿπ ${newTask.multiTasks.length} ŸÖŸáŸÖÿ©`,
      });
    },
    onError: (error: any) => {
      console.error('‚ùå Frontend: Add task failed:', error);
      toast({
        title: "ŸÅÿ¥ŸÑ ŸÅŸä ÿ•ÿ∂ÿßŸÅÿ© ÿßŸÑÿ®ŸÜÿØ",
        description: error?.response?.data?.message || error.message || "ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ∫Ÿäÿ± ŸÖÿ™ŸàŸÇÿπ",
        variant: "destructive",
      });
    },
  });

  const handleAddTask = () => {
    console.log('üéØ Frontend: Add task triggered');
    console.log('üéØ Frontend: Current data:', newTask);
    
    // Validate required fields
    if (!selectedLocationId) {
      toast({
        title: "Ÿäÿ±ÿ¨Ÿâ ÿßÿÆÿ™Ÿäÿßÿ± ÿßŸÑŸÖŸàŸÇÿπ",
        description: "ÿßÿÆÿ™ÿ± ÿßŸÑŸÖŸàŸÇÿπ ÿ£ŸàŸÑÿßŸã ŸÇÿ®ŸÑ ÿ•ÿ∂ÿßŸÅÿ© ÿßŸÑÿ®ŸÜÿØ",
        variant: "destructive",
      });
      return;
    }
    
    if (!newTask.taskAr.trim()) {
      toast({
        title: "ÿßÿ≥ŸÖ ÿßŸÑÿ®ŸÜÿØ ŸÖÿ∑ŸÑŸàÿ®",
        description: "Ÿäÿ±ÿ¨Ÿâ ÿ•ÿØÿÆÿßŸÑ ÿßÿ≥ŸÖ ÿßŸÑÿ®ŸÜÿØ ÿ®ÿßŸÑÿπÿ±ÿ®Ÿäÿ©",
        variant: "destructive",
      });
      return;
    }
    
    if (!newTask.categoryAr.trim()) {
      toast({
        title: "ŸÅÿ¶ÿ© ÿßŸÑÿ®ŸÜÿØ ŸÖÿ∑ŸÑŸàÿ®ÿ©",
        description: "Ÿäÿ±ÿ¨Ÿâ ÿ•ÿØÿÆÿßŸÑ ŸÅÿ¶ÿ© ÿßŸÑÿ®ŸÜÿØ ÿ®ÿßŸÑÿπÿ±ÿ®Ÿäÿ©",
        variant: "destructive",
      });
      return;
    }

    // Validate at least one multi-task
    const validMultiTasks = newTask.multiTasks.filter(task => task.ar.trim() !== "");
    if (validMultiTasks.length === 0) {
      toast({
        title: "ŸÖÿ∑ŸÑŸàÿ® ŸÖŸáŸÖÿ© Ÿàÿßÿ≠ÿØÿ© ÿπŸÑŸâ ÿßŸÑÿ£ŸÇŸÑ",
        description: "Ÿäÿ±ÿ¨Ÿâ ÿ•ÿØÿÆÿßŸÑ ŸÖŸáŸÖÿ© Ÿàÿßÿ≠ÿØÿ© ÿπŸÑŸâ ÿßŸÑÿ£ŸÇŸÑ ŸÑŸÑÿ®ŸÜÿØ",
        variant: "destructive",
      });
      return;
    }

    // Process multi-tasks only (sub-points and sub-tasks removed for simplicity)

    const processedMultiTasks = validMultiTasks.map(task => ({
      ar: task.ar.trim(),
      en: task.en?.trim() || task.ar.trim()
    }));

    addTaskMutation.mutate({
      locationId: selectedLocationId,
      categoryAr: newTask.categoryAr.trim(),
      categoryEn: newTask.categoryEn.trim() || newTask.categoryAr.trim(),
      taskAr: newTask.taskAr.trim(),
      taskEn: newTask.taskEn.trim() || newTask.taskAr.trim(),
      descriptionAr: newTask.descriptionAr.trim(),
      descriptionEn: newTask.descriptionEn.trim() || newTask.descriptionAr.trim(),

      multiTasks: processedMultiTasks,

    });
  };

  // Delete task mutation
  const deleteTaskMutation = useMutation({
    mutationFn: async (taskId: number) => {
      console.log('üóëÔ∏è Frontend: Deleting task ID:', taskId);
      return apiRequest(`/api/checklist-templates/${taskId}`, 'DELETE');
    },
    onSuccess: (data, taskId) => {
      console.log('‚úÖ Frontend: Task deleted successfully:', taskId);
      queryClient.invalidateQueries({ queryKey: [`/api/locations/${selectedLocationId}/templates`] });
      toast({
        title: "ÿ™ŸÖ ÿ≠ÿ∞ŸÅ ÿßŸÑÿ®ŸÜÿØ ÿ®ŸÜÿ¨ÿßÿ≠",
        description: "ÿ™ŸÖ ÿ•ÿ≤ÿßŸÑÿ© ÿßŸÑÿ®ŸÜÿØ ŸÖŸÜ ŸÇÿßÿ¶ŸÖÿ© ÿßŸÑÿ™ÿ¥ŸäŸäŸÉ ŸÜŸáÿßÿ¶ŸäÿßŸã",
      });
    },
    onError: (error: any, taskId) => {
      console.error('‚ùå Frontend: Delete task failed:', error, 'Task ID:', taskId);
      toast({
        title: "ŸÅÿ¥ŸÑ ŸÅŸä ÿ≠ÿ∞ŸÅ ÿßŸÑÿ®ŸÜÿØ",
        description: error?.response?.data?.message || error.message || "ÿ™ÿπÿ∞ÿ± ÿ≠ÿ∞ŸÅ ÿßŸÑÿ®ŸÜÿØ",
        variant: "destructive",
      });
    },
  });

  // Update task mutation
  const updateTaskMutation = useMutation({
    mutationFn: async (data: { id: number; updates: Partial<NewTask> }) => {
      console.log('üîÑ Frontend: Updating task with data:', data);
      return apiRequest(`/api/checklist-templates/${data.id}`, 'PUT', data.updates);
    },
    onSuccess: (data) => {
      console.log('‚úÖ Frontend: Task updated successfully:', data);
      queryClient.invalidateQueries({ queryKey: [`/api/locations/${selectedLocationId}/templates`] });
      resetEditTask();
      setIsEditDialogOpen(false);
      setEditingTask(null);
      toast({
        title: "ÿ™ŸÖ ÿ™ÿ≠ÿØŸäÿ´ ÿßŸÑÿ®ŸÜÿØ ÿ®ŸÜÿ¨ÿßÿ≠",
        description: "ÿ™ŸÖ ÿ≠ŸÅÿ∏ ÿßŸÑÿ™ÿ∫ŸäŸäÿ±ÿßÿ™",
      });
    },
    onError: (error: any) => {
      console.error('‚ùå Frontend: Update task failed:', error);
      toast({
        title: "ŸÅÿ¥ŸÑ ŸÅŸä ÿ™ÿ≠ÿØŸäÿ´ ÿßŸÑÿ®ŸÜÿØ",
        description: error?.response?.data?.message || error.message || "ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ∫Ÿäÿ± ŸÖÿ™ŸàŸÇÿπ",
        variant: "destructive",
      });
    },
  });

  const handleEditTask = (task: ChecklistTemplate) => {
    setEditingTask(task);
    setEditTask({
      categoryAr: task.categoryAr,
      categoryEn: task.categoryEn,
      taskAr: task.taskAr,
      taskEn: task.taskEn,
      descriptionAr: task.descriptionAr || "",
      descriptionEn: task.descriptionEn || "",
      multiTasks: task.multiTasks && task.multiTasks.length > 0 
        ? task.multiTasks 
        : [{ ar: "", en: "" }],
    });
    setIsEditDialogOpen(true);
  };

  const handleUpdateTask = () => {
    if (!editingTask) return;

    // Validate required fields
    if (!editTask.taskAr.trim()) {
      toast({
        title: "ÿßÿ≥ŸÖ ÿßŸÑÿ®ŸÜÿØ ŸÖÿ∑ŸÑŸàÿ®",
        description: "Ÿäÿ±ÿ¨Ÿâ ÿ•ÿØÿÆÿßŸÑ ÿßÿ≥ŸÖ ÿßŸÑÿ®ŸÜÿØ ÿ®ÿßŸÑÿπÿ±ÿ®Ÿäÿ©",
        variant: "destructive",
      });
      return;
    }
    
    if (!editTask.categoryAr.trim()) {
      toast({
        title: "ŸÅÿ¶ÿ© ÿßŸÑÿ®ŸÜÿØ ŸÖÿ∑ŸÑŸàÿ®ÿ©",
        description: "Ÿäÿ±ÿ¨Ÿâ ÿ•ÿØÿÆÿßŸÑ ŸÅÿ¶ÿ© ÿßŸÑÿ®ŸÜÿØ ÿ®ÿßŸÑÿπÿ±ÿ®Ÿäÿ©",
        variant: "destructive",
      });
      return;
    }

    // Validate at least one multi-task
    const validMultiTasks = editTask.multiTasks.filter(task => task.ar.trim() !== "");
    if (validMultiTasks.length === 0) {
      toast({
        title: "ŸÖÿ∑ŸÑŸàÿ® ŸÖŸáŸÖÿ© Ÿàÿßÿ≠ÿØÿ© ÿπŸÑŸâ ÿßŸÑÿ£ŸÇŸÑ",
        description: "Ÿäÿ±ÿ¨Ÿâ ÿ•ÿØÿÆÿßŸÑ ŸÖŸáŸÖÿ© Ÿàÿßÿ≠ÿØÿ© ÿπŸÑŸâ ÿßŸÑÿ£ŸÇŸÑ ŸÑŸÑÿ®ŸÜÿØ",
        variant: "destructive",
      });
      return;
    }

    const processedMultiTasks = validMultiTasks.map(task => ({
      ar: task.ar.trim(),
      en: task.en?.trim() || task.ar.trim()
    }));

    updateTaskMutation.mutate({
      id: editingTask.id,
      updates: {
        categoryAr: editTask.categoryAr.trim(),
        categoryEn: editTask.categoryEn.trim() || editTask.categoryAr.trim(),
        taskAr: editTask.taskAr.trim(),
        taskEn: editTask.taskEn.trim() || editTask.taskAr.trim(),
        descriptionAr: editTask.descriptionAr.trim(),
        descriptionEn: editTask.descriptionEn.trim() || editTask.descriptionAr.trim(),
        multiTasks: processedMultiTasks,
      }
    });
  };

  const handleDeleteTask = (taskId: number, taskName: string) => {
    // ÿ•ÿµŸÑÿßÿ≠ ŸÖÿ§ŸÇÿ™ ŸÑŸÖŸÜÿπ ÿ¨ŸÖŸàÿØ UI - ÿßÿ≥ÿ™ÿ®ÿØÿßŸÑ confirm ÿßŸÑŸÖÿ≠ÿ¨Ÿàÿ®
    setTimeout(() => {
      if (window.confirm(`ŸáŸÑ ÿ£ŸÜÿ™ ŸÖÿ™ÿ£ŸÉÿØ ŸÖŸÜ ÿ≠ÿ∞ŸÅ ÿßŸÑÿ®ŸÜÿØ "${taskName}"ÿü\n\nŸáÿ∞ÿß ÿßŸÑÿ•ÿ¨ÿ±ÿßÿ° ŸÑÿß ŸäŸÖŸÉŸÜ ÿßŸÑÿ™ÿ±ÿßÿ¨ÿπ ÿπŸÜŸá.`)) {
        deleteTaskMutation.mutate(taskId);
      }
    }, 0);
  };

  // Update template order mutation
  const updateTemplateOrderMutation = useMutation({
    mutationFn: async (templatesData: { id: number; orderIndex: number }[]) => {
      console.log('üìä Templates to update:', templatesData);
      
      if (isOffline) {
        // Save order changes to IndexedDB first, then localStorage for later sync
        try {
          const { enhancedIndexedDB } = await import("@/lib/enhancedIndexedDB");
          const storedChanges = await enhancedIndexedDB.getAuthData('pendingTemplateOrderChanges') || '[]';
          const pendingChanges = typeof storedChanges === 'string' ? JSON.parse(storedChanges) : (Array.isArray(storedChanges) ? storedChanges : []);
          const newChange = {
            timestamp: Date.now(),
            templates: templatesData,
            locationId: selectedLocationId
          };
          pendingChanges.push(newChange);
          await enhancedIndexedDB.saveAuthData('pendingTemplateOrderChanges', pendingChanges);
          console.log('‚úÖ ÿ™ŸÖ ÿ≠ŸÅÿ∏ ÿ™ÿ∫ŸäŸäÿ±ÿßÿ™ ÿßŸÑÿ™ÿ±ÿ™Ÿäÿ® ŸÅŸä IndexedDB');
        } catch (error) {
          console.warn('‚ö†Ô∏è ŸÅÿ¥ŸÑ ÿ≠ŸÅÿ∏ ÿßŸÑÿ™ÿ∫ŸäŸäÿ±ÿßÿ™ ŸÅŸä IndexedDB:', error);
          
          // ŸÑÿß ŸäŸàÿ¨ÿØ ÿßÿ≠ÿ™Ÿäÿßÿ∑Ÿä - IndexedDB ŸÅŸÇÿ∑
          throw error;
          
        }
        return { message: 'Changes saved offline' };
      }
      
      return apiRequest('/api/checklist-templates/reorder', 'PUT', {
        templates: templatesData
      });
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: [`/api/locations/${selectedLocationId}/templates`] });
      toast({
        title: "ÿ™ŸÖ ÿ™ÿ≠ÿØŸäÿ´ ÿßŸÑÿ™ÿ±ÿ™Ÿäÿ® ÿ®ŸÜÿ¨ÿßÿ≠",
        description: isOffline ? "ÿ≥Ÿäÿ™ŸÖ ÿ™ÿ∑ÿ®ŸäŸÇ ÿßŸÑÿ™ÿ∫ŸäŸäÿ±ÿßÿ™ ÿπŸÜÿØ ÿßŸÑÿßÿ™ÿµÿßŸÑ" : "ÿ™ŸÖ ÿ≠ŸÅÿ∏ ÿßŸÑÿ™ÿ±ÿ™Ÿäÿ® ÿßŸÑÿ¨ÿØŸäÿØ",
      });
    },
    onError: (error: any) => {
      console.error('Location order update error:', error);
      toast({
        title: "ŸÅÿ¥ŸÑ ŸÅŸä ÿ™ÿ≠ÿØŸäÿ´ ÿßŸÑÿ™ÿ±ÿ™Ÿäÿ®",
        description: error?.response?.data?.message || "ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ÿßŸÑÿ≠ŸÅÿ∏",
        variant: "destructive",
      });
    }
  });

  // Drag and drop handlers
  const handleDragStart = (e: React.DragEvent, template: ChecklistTemplate) => {
    setDraggedTemplate(template);
    e.dataTransfer.effectAllowed = 'move';
  };

  const handleDragOver = (e: React.DragEvent, template: ChecklistTemplate) => {
    e.preventDefault();
    e.dataTransfer.dropEffect = 'move';
    setDragOverTemplate(template);
  };

  const handleDragLeave = () => {
    setDragOverTemplate(null);
  };

  const handleDrop = (e: React.DragEvent, targetTemplate: ChecklistTemplate) => {
    e.preventDefault();
    
    if (!draggedTemplate || draggedTemplate.id === targetTemplate.id) {
      setDraggedTemplate(null);
      setDragOverTemplate(null);
      return;
    }

    if (!templates) return;

    // Find current positions
    const draggedIndex = templates.findIndex(template => template.id === draggedTemplate.id);
    const targetIndex = templates.findIndex(template => template.id === targetTemplate.id);

    if (draggedIndex === -1 || targetIndex === -1) return;

    // Create new order
    const newTemplates = [...templates];
    const [draggedItem] = newTemplates.splice(draggedIndex, 1);
    newTemplates.splice(targetIndex, 0, draggedItem);

    // Update order indices
    const templatesWithNewOrder = newTemplates.map((template, index) => ({
      id: template.id,
      orderIndex: index
    }));

    // Apply changes immediately (optimistic update)
    queryClient.setQueryData([`/api/locations/${selectedLocationId}/templates`], newTemplates);

    // Send to server
    updateTemplateOrderMutation.mutate(templatesWithNewOrder);

    setDraggedTemplate(null);
    setDragOverTemplate(null);
  };

  const handleDragEnd = () => {
    setDraggedTemplate(null);
    setDragOverTemplate(null);
  };

  // Group templates by category
  const groupedTemplates = templates?.reduce((acc, template) => {
    const category = template.categoryAr || 'ÿ®ÿØŸàŸÜ ÿ™ÿµŸÜŸäŸÅ';
    if (!acc[category]) {
      acc[category] = [];
    }
    acc[category].push(template);
    return acc;
  }, {} as Record<string, ChecklistTemplate[]>) || {};

  const selectedLocation = locations?.find(loc => loc.id === selectedLocationId);

  console.log('üìã Checklist Manager Data Status:', { 
    locationsLoading, 
    locations, 
    hasLocationsData: !!locations,
    locationsLength: locations?.length || 0,
    locationsError: locationsError?.message,
    showLoadingScreen: locationsLoading && !locations,
    firstLocation: locations?.[0],
    userToken: 'IndexedDB-based' // Token now stored in IndexedDB
  });

  // Only show loading screen if there's no data AND it's loading
  if (locationsLoading && !locations) {
    return (
      <main className="flex flex-col min-h-screen bg-gray-50">
        <div className="flex-1 container mx-auto px-4 py-8">
          <LoadingSpinner />
        </div>
      </main>
    );
  }

  const IconComponent: LucideIcon = selectedLocation ? 
    (iconMap[selectedLocation.icon as keyof typeof iconMap] || Building) : Building;

  return (
    <main className="flex flex-col min-h-screen bg-gray-50">
      
      
      <div className="flex-1 container mx-auto px-4 py-8">
        <div className="space-y-6">
          <div>
            <h1 className="text-3xl font-bold text-gray-900">ÿ•ÿØÿßÿ±ÿ© ŸÇŸàÿßÿ¶ŸÖ ÿßŸÑÿ™ÿ¥ŸäŸäŸÉ</h1>
            <p className="text-gray-600 mt-2">ÿ™ÿ≠ÿ±Ÿäÿ± Ÿàÿ•ÿØÿßÿ±ÿ© ŸÇŸàÿßÿ¶ŸÖ ÿßŸÑŸÖŸáÿßŸÖ ŸÑŸÉŸÑ ŸÖŸàŸÇÿπ</p>
          </div>

          {/* Debug Info for Development */}
          {process.env.NODE_ENV === 'development' && (
            <div className="mb-4 p-3 bg-blue-50 border border-blue-200 rounded-lg text-sm">
              <p><strong>Debug:</strong> ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™ ÿßŸÑÿÆÿßŸÖ: {JSON.stringify(locations?.slice(0,2))}</p>
              <p><strong>ÿπÿØÿØ ÿßŸÑŸÖŸàÿßŸÇÿπ:</strong> {locations?.length || 0}</p>
              <p><strong>ÿ£ŸàŸÑ ŸÖŸàŸÇÿπ:</strong> {locations?.[0]?.nameAr || 'ŸÑÿß ŸäŸàÿ¨ÿØ'}</p>
              <p><strong>ÿ≠ÿßŸÑÿ© ÿßŸÑÿ™ÿ≠ŸÖŸäŸÑ:</strong> {locationsLoading ? 'Ÿäÿ≠ŸÖŸëŸÑ' : 'ŸÖŸÉÿ™ŸÖŸÑ'}</p>
              <p><strong>ÿÆÿ∑ÿ£:</strong> {locationsError?.message || 'ŸÑÿß ŸäŸàÿ¨ÿØ'}</p>
            </div>
          )}

          {/* Empty State */}
          {!locationsLoading && (!locations || locations.length === 0) && (
            <div className="text-center py-12">
              <div className="w-24 h-24 mx-auto bg-gray-100 rounded-full flex items-center justify-center mb-4">
                <Building className="h-12 w-12 text-gray-400" />
              </div>
              <h3 className="text-lg font-medium text-gray-900 mb-2">ŸÑÿß ÿ™Ÿàÿ¨ÿØ ŸÖŸàÿßŸÇÿπ</h3>
              <p className="text-gray-500">Ÿäÿ¨ÿ® ÿ•ÿ∂ÿßŸÅÿ© ŸÖŸàÿßŸÇÿπ ÿ£ŸàŸÑÿßŸã ŸÖŸÜ ÿµŸÅÿ≠ÿ© ÿ•ÿØÿßÿ±ÿ© ÿßŸÑŸÖŸàÿßŸÇÿπ</p>
            </div>
          )}

          {/* Locations Grid */}
          <div className="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-4">
            {locations?.map((location) => {
              const IconComponent: LucideIcon = iconMap[location.icon as keyof typeof iconMap] || Building;
              const isSelected = selectedLocationId === location.id;
              
              return (
                <div
                  key={location.id}
                  className={`
                    p-4 rounded-lg border-2 cursor-pointer transition-all duration-200 hover:shadow-md
                    ${isSelected 
                      ? 'border-brand-yellow bg-brand-yellow/10 shadow-lg' 
                      : 'border-gray-200 bg-white hover:border-gray-300'
                    }
                  `}
                  onClick={() => setSelectedLocationId(location.id)}
                >
                  <div className="flex flex-col items-center text-center space-y-2">
                    <div className={`
                      w-12 h-12 rounded-lg flex items-center justify-center
                      ${isSelected ? 'bg-brand-yellow' : 'bg-gray-100'}
                    `}>
                      <IconComponent className={`h-6 w-6 ${
                        isSelected ? 'text-brand-black' : 'text-gray-600'
                      }`} />
                    </div>
                    <div>
                      <h3 className={`font-medium ${
                        isSelected ? 'text-brand-black' : 'text-gray-900'
                      }`}>
                        {location.nameAr}
                      </h3>
                      <p className={`text-sm ${
                        isSelected ? 'text-brand-black opacity-75' : 'text-gray-500'
                      }`}>
                        {location.nameEn}
                      </p>
                    </div>
                  </div>
                </div>
              );
            })}
          </div>

          {selectedLocationId && (
            <>
              {/* Selected Location Info and Add Button */}
              <div className="flex items-center justify-between mb-6">
                <div className="flex items-center gap-3">
                  <div className="w-8 h-8 bg-brand-yellow rounded-lg flex items-center justify-center">
                    <IconComponent className="h-4 w-4 text-brand-black" />
                  </div>
                  <h2 className="text-lg font-semibold text-gray-900">{selectedLocation?.nameAr}</h2>
                </div>

                <Dialog open={isAddDialogOpen} onOpenChange={setIsAddDialogOpen}>
                  <DialogTrigger asChild>
                    <Button className="bg-green-500 hover:bg-green-600 text-white">
                      <Plus className="h-4 w-4 ml-2" />
                      ÿ•ÿ∂ÿßŸÅÿ© ÿ®ŸÜÿØ ÿ¨ÿØŸäÿØ
                    </Button>
                  </DialogTrigger>
                  <DialogContent className="max-w-4xl max-h-[90vh] overflow-y-auto">
                    <DialogHeader>
                      <DialogTitle>ÿ•ÿ∂ÿßŸÅÿ© ÿ®ŸÜÿØ ÿ™ŸÇŸäŸäŸÖ ÿ¨ÿØŸäÿØ ŸÖÿπ ŸÖŸáÿßŸÖ ŸÖÿ™ÿπÿØÿØÿ©</DialogTitle>
                    </DialogHeader>
                    
                    <div className="space-y-6 py-4">
                      {/* Basic Information */}
                      <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                        <div>
                          <Label>ÿßŸÑÿ™ÿµŸÜŸäŸÅ ÿ®ÿßŸÑÿπÿ±ÿ®Ÿäÿ© *</Label>
                          <Input
                            autoFocus
                            value={newTask.categoryAr}
                            onChange={(e) => setNewTask({...newTask, categoryAr: e.target.value})}
                            placeholder="ŸÖÿ´ŸÑ: ÿ™ŸÜÿ∏ŸäŸÅ ÿßŸÑÿ£ÿ±ÿ∂Ÿäÿßÿ™"
                            className="text-sm"
                          />
                        </div>
                        <div>
                          <Label>ÿßŸÑÿ™ÿµŸÜŸäŸÅ ÿ®ÿßŸÑÿ•ŸÜÿ¨ŸÑŸäÿ≤Ÿäÿ©</Label>
                          <Input
                            value={newTask.categoryEn}
                            onChange={(e) => setNewTask({...newTask, categoryEn: e.target.value})}
                            placeholder="e.g: Floor Cleaning"
                            className="text-sm"
                          />
                        </div>
                      </div>
                      
                      <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                        <div>
                          <Label>ÿßÿ≥ŸÖ ÿßŸÑÿ®ŸÜÿØ ÿ®ÿßŸÑÿπÿ±ÿ®Ÿäÿ© *</Label>
                          <Input
                            value={newTask.taskAr}
                            onChange={(e) => setNewTask({...newTask, taskAr: e.target.value})}
                            placeholder="ŸÖÿ´ŸÑ: ÿ™ŸÜÿ∏ŸäŸÅ ÿßŸÑŸÖŸÉÿßÿ™ÿ®"
                            className="text-sm"
                          />
                        </div>
                        <div>
                          <Label>ÿßÿ≥ŸÖ ÿßŸÑÿ®ŸÜÿØ ÿ®ÿßŸÑÿ•ŸÜÿ¨ŸÑŸäÿ≤Ÿäÿ©</Label>
                          <Input
                            value={newTask.taskEn}
                            onChange={(e) => setNewTask({...newTask, taskEn: e.target.value})}
                            placeholder="e.g: Office Cleaning"
                            className="text-sm"
                          />
                        </div>
                      </div>
                      
                      <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                        <div>
                          <Label>ÿßŸÑŸàÿµŸÅ ÿ®ÿßŸÑÿπÿ±ÿ®Ÿäÿ©</Label>
                          <Textarea
                            value={newTask.descriptionAr}
                            onChange={(e) => setNewTask({...newTask, descriptionAr: e.target.value})}
                            placeholder="ŸàÿµŸÅ ÿ™ŸÅÿµŸäŸÑŸä ŸÑŸÑÿ®ŸÜÿØ"
                            rows={2}
                            className="text-sm"
                          />
                        </div>
                        <div>
                          <Label>ÿßŸÑŸàÿµŸÅ ÿ®ÿßŸÑÿ•ŸÜÿ¨ŸÑŸäÿ≤Ÿäÿ©</Label>
                          <Textarea
                            value={newTask.descriptionEn}
                            onChange={(e) => setNewTask({...newTask, descriptionEn: e.target.value})}
                            placeholder="Detailed description"
                            rows={2}
                            className="text-sm"
                          />
                        </div>
                      </div>







                      {/* Multi-Tasks Section */}
                      <div className="border border-green-200 rounded-lg p-4 bg-green-50">
                        <div className="flex items-center justify-between mb-3">
                          <h4 className="text-lg font-medium text-green-700">ÿßŸÑŸÖŸáÿßŸÖ ÿßŸÑŸÖÿ™ÿπÿØÿØÿ© *</h4>
                          <Button
                            type="button"
                            variant="outline"
                            size="sm"
                            onClick={addMultiTask}
                            className="text-green-600 border-green-300 hover:bg-green-100"
                          >
                            <Plus className="h-4 w-4 ml-1" />
                            ÿ•ÿ∂ÿßŸÅÿ© ŸÖŸáŸÖÿ©
                          </Button>
                        </div>
                        <p className="text-sm text-green-600 mb-3 bg-green-100 p-2 rounded">
                          üéØ ŸÉŸÑ ÿ®ŸÜÿØ ŸäŸÖŸÉŸÜ ÿ£ŸÜ Ÿäÿ≠ÿ™ŸàŸä ÿπŸÑŸâ ÿπÿØÿ© ŸÖŸáÿßŸÖ (ŸÖÿ´ŸÑ: ŸÖÿ≥ÿ≠ ÿßŸÑÿ£ÿ≥ÿ∑ÿ≠ÿå ÿ™ÿ±ÿ™Ÿäÿ® ÿßŸÑÿ£Ÿàÿ±ÿßŸÇÿå ÿ™ŸÜÿ∏ŸäŸÅ ÿßŸÑÿ£ÿØÿ±ÿßÿ¨)
                        </p>
                        
                        <div className="space-y-3 max-h-64 overflow-y-auto">
                          {newTask.multiTasks.map((multiTask, index) => (
                            <div key={index} className="bg-green-100 rounded-lg p-3 border border-green-200">
                              <div className="flex items-center justify-between mb-2">
                                <span className="text-sm font-medium text-green-800">ÿßŸÑŸÖŸáŸÖÿ© {index + 1}</span>
                                {newTask.multiTasks.length > 1 && (
                                  <Button
                                    type="button"
                                    variant="ghost"
                                    size="sm"
                                    onClick={() => removeMultiTask(index)}
                                    className="text-red-500 hover:text-red-700 hover:bg-red-50"
                                  >
                                    <X className="h-3 w-3" />
                                  </Button>
                                )}
                              </div>
                              <div className="grid grid-cols-1 md:grid-cols-2 gap-2">
                                <Input
                                  placeholder="ÿßŸÑŸÖŸáŸÖÿ© ÿ®ÿßŸÑÿπÿ±ÿ®Ÿäÿ© *"
                                  value={multiTask.ar}
                                  onChange={(e) => updateMultiTask(index, 'ar', e.target.value)}
                                  className="text-xs"
                                />
                                <Input
                                  placeholder="ÿßŸÑŸÖŸáŸÖÿ© ÿ®ÿßŸÑÿ•ŸÜÿ¨ŸÑŸäÿ≤Ÿäÿ©"
                                  value={multiTask.en || ""}
                                  onChange={(e) => updateMultiTask(index, 'en', e.target.value)}
                                  className="text-xs"
                                />
                              </div>
                            </div>
                          ))}
                        </div>
                      </div>


                    </div>
                    
                    <DialogFooter>
                      <Button variant="outline" onClick={() => setIsAddDialogOpen(false)}>
                        ÿ•ŸÑÿ∫ÿßÿ°
                      </Button>
                      <Button 
                        onClick={handleAddTask}
                        disabled={addTaskMutation.isPending || !newTask.taskAr.trim() || !newTask.categoryAr.trim() || newTask.multiTasks.filter(task => task.ar.trim()).length === 0}
                        className="bg-brand-yellow text-brand-black hover:bg-yellow-400"
                      >
                        {addTaskMutation.isPending ? "ÿ¨ÿßÿ±Ÿä ÿßŸÑÿ•ÿ∂ÿßŸÅÿ©..." : "ÿ•ÿ∂ÿßŸÅÿ© ÿßŸÑÿ®ŸÜÿØ"}
                      </Button>
                    </DialogFooter>
                  </DialogContent>
                </Dialog>
              </div>

              {templatesLoading ? (
                <LoadingSpinner />
              ) : (
                <div className="space-y-6">
                  {Object.entries(groupedTemplates).map(([category, categoryTemplates]: [string, any]) => (
                    <Card key={category}>
                      <CardHeader>
                        <CardTitle className="flex items-center gap-2">
                          <div className="w-2 h-2 bg-brand-yellow rounded-full"></div>
                          {category}
                        </CardTitle>
                      </CardHeader>
                      <CardContent>
                        <div className="space-y-3">
                          {categoryTemplates.map((template: ChecklistTemplate, index: number) => (
                            <div 
                              key={template.id} 
                              className={`
                                relative group bg-gray-50 rounded-lg p-4 cursor-move transition-all duration-200
                                ${draggedTemplate?.id === template.id ? 'bg-blue-100 border-2 border-blue-300 shadow-lg' : ''}
                                ${dragOverTemplate?.id === template.id ? 'bg-yellow-100 border-2 border-yellow-300' : ''}
                                hover:bg-gray-100
                              `}
                              draggable
                              onDragStart={(e) => handleDragStart(e, template)}
                              onDragOver={(e) => handleDragOver(e, template)}
                              onDragLeave={handleDragLeave}
                              onDrop={(e) => handleDrop(e, template)}
                              onDragEnd={handleDragEnd}
                            >
                              {/* Drag handle */}
                              <div className="absolute top-2 right-2 opacity-0 group-hover:opacity-100 transition-opacity">
                                <GripVertical className="h-4 w-4 text-gray-400 cursor-move" />
                              </div>

                              <div className="flex items-start justify-between">
                                <div className="flex-1">
                                  <h4 className="font-medium text-gray-900 mb-1">
                                    {template.taskAr}
                                  </h4>
                                  {template.descriptionAr && (
                                    <p className="text-sm text-gray-600 mb-2">{template.descriptionAr}</p>
                                  )}
                                  
                                  {/* Sub-points display */}
                                  {template.subPoints && template.subPoints.length > 0 && (
                                    <div className="mt-2 space-y-1">
                                      <p className="text-xs font-medium text-gray-700 mb-1">ÿßŸÑŸÜŸÇÿßÿ∑ ÿßŸÑŸÅÿ±ÿπŸäÿ©:</p>
                                      <ul className="space-y-1">
                                        {template.subPoints.map((subPoint: SubPoint, index: number) => (
                                          <li key={index} className="text-xs text-gray-600 flex items-start">
                                            <span className="inline-block w-1.5 h-1.5 bg-brand-yellow rounded-full mt-1.5 ml-2 flex-shrink-0"></span>
                                            <span>{subPoint.ar}</span>
                                          </li>
                                        ))}
                                      </ul>
                                    </div>
                                  )}

                                  {/* Sub-tasks display */}
                                  {template.subTasks && template.subTasks.length > 0 && (
                                    <div className="mt-2 space-y-1">
                                      <p className="text-xs font-medium text-blue-700 mb-1">ÿßŸÑŸÖŸáÿßŸÖ ÿßŸÑŸÅÿ±ÿπŸäÿ©:</p>
                                      <ul className="space-y-1">
                                        {template.subTasks.map((subTask: SubTask, index: number) => (
                                          <li key={index} className="text-xs text-blue-600 flex items-start">
                                            <span className="inline-block w-1.5 h-1.5 bg-blue-500 rounded-full mt-1.5 ml-2 flex-shrink-0"></span>
                                            <span>{subTask.ar}</span>
                                          </li>
                                        ))}
                                      </ul>
                                    </div>
                                  )}

                                  {/* Multi-tasks display */}
                                  {template.multiTasks && template.multiTasks.length > 0 && (
                                    <div className="mt-2 space-y-1">
                                      <p className="text-xs font-medium text-green-700 mb-1">ÿßŸÑŸÖŸáÿßŸÖ ÿßŸÑŸÖÿ™ÿπÿØÿØÿ©:</p>
                                      <ul className="space-y-1">
                                        {template.multiTasks.map((multiTask: MultiTask, index: number) => (
                                          <li key={index} className="text-xs text-green-600 flex items-start">
                                            <span className="inline-block w-1.5 h-1.5 bg-green-500 rounded-full mt-1.5 ml-2 flex-shrink-0"></span>
                                            <span>{multiTask.ar}</span>
                                          </li>
                                        ))}
                                      </ul>
                                    </div>
                                  )}


                                </div>
                                
                                <div className="flex gap-2 ml-4">
                                  <Button
                                    variant="ghost"
                                    size="sm"
                                    onClick={() => handleEditTask(template)}
                                    disabled={updateTaskMutation.isPending}
                                    className="text-blue-600 hover:text-blue-700 hover:bg-blue-50"
                                  >
                                    <Edit className="h-4 w-4" />
                                  </Button>
                                  <Button
                                    variant="ghost"
                                    size="sm"
                                    onClick={() => handleDeleteTask(template.id, template.taskAr)}
                                    disabled={deleteTaskMutation.isPending}
                                    className="text-red-600 hover:text-red-700 hover:bg-red-50"
                                  >
                                    <Trash2 className="h-4 w-4" />
                                  </Button>
                                </div>
                              </div>
                            </div>
                          ))}
                        </div>
                      </CardContent>
                    </Card>
                  ))}
                  
                  {Object.keys(groupedTemplates).length === 0 && (
                    <div className="text-center py-12">
                      <div className="w-16 h-16 bg-gray-100 rounded-full flex items-center justify-center mx-auto mb-4">
                        <Building className="h-8 w-8 text-gray-400" />
                      </div>
                      <h3 className="text-lg font-medium text-gray-900 mb-2">ŸÑÿß ÿ™Ÿàÿ¨ÿØ ŸÇŸàÿßÿ¶ŸÖ ÿ™ÿ¥ŸäŸäŸÉ</h3>
                      <p className="text-gray-600 mb-4">
                        ŸÑŸÖ Ÿäÿ™ŸÖ ÿ•ŸÜÿ¥ÿßÿ° ÿ£Ÿä ŸÇŸàÿßÿ¶ŸÖ ÿ™ÿ¥ŸäŸäŸÉ ŸÑŸáÿ∞ÿß ÿßŸÑŸÖŸàŸÇÿπ ÿ®ÿπÿØ
                      </p>
                    </div>
                  )}
                </div>
              )}
            </>
          )}

          {!selectedLocationId && (
            <div className="text-center py-12">
              <div className="w-16 h-16 bg-gray-100 rounded-full flex items-center justify-center mx-auto mb-4">
                <Building className="h-8 w-8 text-gray-400" />
              </div>
              <h3 className="text-lg font-medium text-gray-900 mb-2">ÿßÿÆÿ™ÿ± ŸÖŸàŸÇÿπÿßŸã ŸÑÿ•ÿØÿßÿ±ÿ© ŸÇŸàÿßÿ¶ŸÖ ÿßŸÑÿ™ÿ¥ŸäŸäŸÉ</h3>
              <p className="text-gray-600">ÿßÿÆÿ™ÿ± ÿ£ÿ≠ÿØ ÿßŸÑŸÖŸàÿßŸÇÿπ ÿ£ÿπŸÑÿßŸá ŸÑÿπÿ±ÿ∂ Ÿàÿ•ÿØÿßÿ±ÿ© ŸÇŸàÿßÿ¶ŸÖ ÿßŸÑÿ™ÿ¥ŸäŸäŸÉ ÿßŸÑÿÆÿßÿµÿ© ÿ®Ÿá</p>
            </div>
          )}
        </div>

        {/* Edit Task Dialog */}
        <Dialog open={isEditDialogOpen} onOpenChange={setIsEditDialogOpen}>
          <DialogContent className="max-w-2xl max-h-[90vh] overflow-y-auto">
            <DialogHeader>
              <DialogTitle>ÿ™ÿπÿØŸäŸÑ ÿ®ŸÜÿØ ŸÇÿßÿ¶ŸÖÿ© ÿßŸÑÿ™ÿ¥ŸäŸäŸÉ</DialogTitle>
            </DialogHeader>
            <div className="grid gap-6 py-4">
              <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                <div>
                  <Label htmlFor="editCategoryAr">ŸÅÿ¶ÿ© ÿßŸÑÿ®ŸÜÿØ ÿ®ÿßŸÑÿπÿ±ÿ®Ÿäÿ© *</Label>
                  <Input
                    id="editCategoryAr"
                    autoFocus
                    value={editTask.categoryAr}
                    onChange={(e) => setEditTask({ ...editTask, categoryAr: e.target.value })}
                    placeholder="ÿ£ÿØÿÆŸÑ ŸÅÿ¶ÿ© ÿßŸÑÿ®ŸÜÿØ"
                  />
                </div>
                <div>
                  <Label htmlFor="editCategoryEn">ŸÅÿ¶ÿ© ÿßŸÑÿ®ŸÜÿØ ÿ®ÿßŸÑÿ•ŸÜÿ¨ŸÑŸäÿ≤Ÿäÿ©</Label>
                  <Input
                    id="editCategoryEn"
                    value={editTask.categoryEn}
                    onChange={(e) => setEditTask({ ...editTask, categoryEn: e.target.value })}
                    placeholder="Enter category in English"
                    dir="ltr"
                  />
                </div>
              </div>

              <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                <div>
                  <Label htmlFor="editTaskAr">ÿßÿ≥ŸÖ ÿßŸÑÿ®ŸÜÿØ ÿ®ÿßŸÑÿπÿ±ÿ®Ÿäÿ© *</Label>
                  <Input
                    id="editTaskAr"
                    value={editTask.taskAr}
                    onChange={(e) => setEditTask({ ...editTask, taskAr: e.target.value })}
                    placeholder="ÿ£ÿØÿÆŸÑ ÿßÿ≥ŸÖ ÿßŸÑÿ®ŸÜÿØ"
                  />
                </div>
                <div>
                  <Label htmlFor="editTaskEn">ÿßÿ≥ŸÖ ÿßŸÑÿ®ŸÜÿØ ÿ®ÿßŸÑÿ•ŸÜÿ¨ŸÑŸäÿ≤Ÿäÿ©</Label>
                  <Input
                    id="editTaskEn"
                    value={editTask.taskEn}
                    onChange={(e) => setEditTask({ ...editTask, taskEn: e.target.value })}
                    placeholder="Enter task name in English"
                    dir="ltr"
                  />
                </div>
              </div>

              <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                <div>
                  <Label htmlFor="editDescriptionAr">ŸàÿµŸÅ ÿßŸÑÿ®ŸÜÿØ ÿ®ÿßŸÑÿπÿ±ÿ®Ÿäÿ©</Label>
                  <Textarea
                    id="editDescriptionAr"
                    value={editTask.descriptionAr}
                    onChange={(e) => setEditTask({ ...editTask, descriptionAr: e.target.value })}
                    placeholder="ŸàÿµŸÅ ÿßÿÆÿ™Ÿäÿßÿ±Ÿä ŸÑŸÑÿ®ŸÜÿØ"
                    rows={3}
                  />
                </div>
                <div>
                  <Label htmlFor="editDescriptionEn">ŸàÿµŸÅ ÿßŸÑÿ®ŸÜÿØ ÿ®ÿßŸÑÿ•ŸÜÿ¨ŸÑŸäÿ≤Ÿäÿ©</Label>
                  <Textarea
                    id="editDescriptionEn"
                    value={editTask.descriptionEn}
                    onChange={(e) => setEditTask({ ...editTask, descriptionEn: e.target.value })}
                    placeholder="Optional description in English"
                    rows={3}
                    dir="ltr"
                  />
                </div>
              </div>

              {/* Multi-tasks Section */}
              <div className="bg-green-50 border border-green-200 rounded-lg p-4">
                <div className="flex items-center justify-between mb-3">
                  <Label className="text-green-800 font-medium">üü¢ ÿßŸÑŸÖŸáÿßŸÖ ÿßŸÑŸÖÿ™ÿπÿØÿØÿ© *</Label>
                  <Button
                    type="button"
                    variant="outline"
                    size="sm"
                    onClick={addEditMultiTask}
                    className="border-green-300 text-green-700 hover:bg-green-100"
                  >
                    <Plus className="h-3 w-3 ml-1" />
                    ÿ•ÿ∂ÿßŸÅÿ© ŸÖŸáŸÖÿ©
                  </Button>
                </div>
                <div className="space-y-3">
                  {editTask.multiTasks.map((multiTask, index) => (
                    <div key={index} className="bg-white border border-green-200 rounded p-3">
                      <div className="flex items-center justify-between mb-2">
                        <span className="text-xs text-green-700 font-medium">ŸÖŸáŸÖÿ© {index + 1}</span>
                        {editTask.multiTasks.length > 1 && (
                          <Button
                            type="button"
                            variant="ghost"
                            size="sm"
                            onClick={() => removeEditMultiTask(index)}
                            className="text-red-500 hover:text-red-700 hover:bg-red-50"
                          >
                            <X className="h-3 w-3" />
                          </Button>
                        )}
                      </div>
                      <div className="grid grid-cols-1 md:grid-cols-2 gap-2">
                        <Input
                          placeholder="ÿßŸÑŸÖŸáŸÖÿ© ÿ®ÿßŸÑÿπÿ±ÿ®Ÿäÿ© *"
                          value={multiTask.ar}
                          onChange={(e) => updateEditMultiTask(index, 'ar', e.target.value)}
                          className="text-xs"
                        />
                        <Input
                          placeholder="ÿßŸÑŸÖŸáŸÖÿ© ÿ®ÿßŸÑÿ•ŸÜÿ¨ŸÑŸäÿ≤Ÿäÿ©"
                          value={multiTask.en || ""}
                          onChange={(e) => updateEditMultiTask(index, 'en', e.target.value)}
                          className="text-xs"
                        />
                      </div>
                    </div>
                  ))}
                </div>
              </div>

            </div>
            
            <DialogFooter>
              <Button variant="outline" onClick={() => setIsEditDialogOpen(false)}>
                ÿ•ŸÑÿ∫ÿßÿ°
              </Button>
              <Button 
                onClick={handleUpdateTask}
                disabled={updateTaskMutation.isPending || !editTask.taskAr.trim() || !editTask.categoryAr.trim() || editTask.multiTasks.filter(task => task.ar.trim()).length === 0}
                className="bg-blue-600 hover:bg-blue-700 text-white"
              >
                {updateTaskMutation.isPending ? "ÿ¨ÿßÿ±Ÿä ÿßŸÑÿ™ÿ≠ÿØŸäÿ´..." : "ÿ≠ŸÅÿ∏ ÿßŸÑÿ™ÿ∫ŸäŸäÿ±ÿßÿ™"}
              </Button>
            </DialogFooter>
          </DialogContent>
        </Dialog>

      </div>
    </main>
  );
}